program suelbackup;

{$APPTYPE CONSOLE}
{$R *.res}

uses
  System.SysUtils,
  System.Classes,
  inifiles,
  Windows,
  System.Json,
  System.Threading,
  System.SyncObjs,
  System.IOUtils,
  System.Net.URLClient,
  System.Net.HttpClient,
  System.Net.HttpClientComponent,
  System.Net.Mime,
  System.Json.Builders,
  System.Json.Types,
  System.Json.Writers;

type
  TAppConfig = class(TObject)
  strict private
    FMySqlDir: string;
    FDatabase: string;
    FPassword: string;
    FWebhook: string;
    FUser: string;
    procedure SetDatabase(const Value: string);
    procedure SetMySqlDir(const Value: string);
    procedure SetPassword(const Value: string);
    procedure SetUser(const Value: string);
    procedure SetWebhook(const Value: string);
    procedure OnCompleteRequest(const Sender: TObject;
      const AResponse: IHTTPResponse);
  public
    class function TestDatabaseConnection(P: TAppConfig): Boolean;
    function ReecriarArquivo: Boolean;
    property Database: string read FDatabase write SetDatabase;
    property User: string read FUser write SetUser;
    property Password: string read FPassword write SetPassword;
    property Webhook: string read FWebhook write SetWebhook;
    property MySqlDir: string read FMySqlDir write SetMySqlDir;
  end;

  TSuelBackupApp = class(TObject)
  strict private
    FConfig: TAppConfig;
  public
    procedure SendToOutPut(const _message: string);
    procedure InicializarBackup();
    function CheckConfiguracao(): Boolean;
    class function GetDosOutput(CommandLine: string; Work: string = 'C:\';
      timeout: Cardinal = INFINITE): string;
    constructor Create();
  end;

  TJSON = class
  private
    FBuilder: TJSONObjectBuilder;
    FWriter: TJsonTextWriter;
    FStringWriter: TStringWriter;
    FStringBuilder: TStringBuilder;
  public
    constructor Create();
    destructor Destroy; override;
    function B: TJSONObjectBuilder;
    function ToString: string; override;
    procedure clear;
  end;

var
  NetHTTPClient: TNetHTTPClient;

  { TAppConfig }

procedure TAppConfig.OnCompleteRequest(const Sender: TObject;
  const AResponse: IHTTPResponse);
begin
  WriteLn(AResponse.StatusText, AResponse.ContentAsString());
end;

function TAppConfig.ReecriarArquivo: Boolean;
var
  a, B, c, d, e: string;
  P: TRequestCompletedEvent;
  j: TJSON;
begin
  WriteLn('Nenhum arquivo de configuração encontrado');
  Write('Coloque o nome do banco de dados: ');
  Readln(a);
  Write('Coloque o usuário do banco de dados: ');
  Readln(B);
  Write('Coloque a senha, deixe em branco de não houver: ');
  Readln(c);
  Write('Coloque o diretório do MYSQL.EXE: ');
  Readln(d);
  Write('Coloque o webhook do canal para onde será enviado o backup: ');
  Readln(e);

  WriteLn('');
  WriteLn('Checando informações');

  if a <> String.Empty then
  begin
    if B <> String.Empty then
    begin
      if d <> String.Empty then
      begin
        if e <> String.Empty then
        begin
          WriteLn('Etapa 1 da verificação das informações foi OK');
          WriteLn('Verificando conexão com o banco e testando WEBHOOK');
          self.FDatabase := a;
          self.FUser := B;
          self.FPassword := c;
          self.FMySqlDir := d;
          self.FWebhook := e;
          if TAppConfig.TestDatabaseConnection(self) then
          begin
            WriteLn('Conexão com o banco de dados: OK');
            WriteLn('Verificando WEBHOOK');
            NetHTTPClient := TNetHTTPClient.Create(nil);
            j := TJSON.Create;
            j.B.BeginObject.BeginArray('embeds').BeginObject.Add('title', 'Webhook')
              .Add('description', 'Testando Webhook').EndObject.EndArray.EndObject;
            NetHTTPClient.ContentType := 'application/json';
            var x := TStringStream.Create(j.ToString, TEncoding.UTF8);
            var post := NetHTTPClient.post(e, x);
            if (post.StatusCode = 200) or (post.StatusCode = 204) then
            begin
                WriteLN('WEBHOOK OK');
                WriteLN('Gerando Arquivo de configuração');
                J.clear;
                j.B.BeginObject
                  .Add('database', a)
                  .Add('user', b)
                  .Add('password', c)
                  .Add('webhook', d)
                  .Add('mysqldir', e).EndObject;
                TStringStream.Create(j.ToString, TEncoding.UTF8).SaveToFile('config.json');
            end
            else
            begin
              WriteLn('FALHA NO TESTE DO WEBHOOK');
            end;
            J.Free;
            NetHTTPClient.Free;
            x.Free;
          end
          else
          begin
            WriteLn('Falha na conexão com o banco de dados!');
          end;
        end
        else
        begin
          WriteLn('Verifique o WEBHOOK, não parece OK.');
        end;
      end
      else
      begin
        WriteLn('Verifique o caminho do MYSQL no seu sistema.');
      end;
    end
    else
    begin
      WriteLn('Verifique o nome o usuário do banco de dados.');
    end;
  end
  else
  begin
    WriteLn('Nome do banco de dados inválido.');
  end;
  WriteLn('');
  WriteLn('Pressione qualquer tecla para continuar');
  Readln;
end;

procedure TAppConfig.SetDatabase(const Value: string);
begin
  FDatabase := Value;
end;

procedure TAppConfig.SetMySqlDir(const Value: string);
begin
  FMySqlDir := Value;
end;

procedure TAppConfig.SetPassword(const Value: string);
begin
  FPassword := Value;
end;

procedure TAppConfig.SetUser(const Value: string);
begin
  FUser := Value;
end;

procedure TAppConfig.SetWebhook(const Value: string);
begin
  FWebhook := Value;
end;

class function TAppConfig.TestDatabaseConnection(P: TAppConfig): Boolean;
begin
  var
  s := TSuelBackupApp.GetDosOutput(P.MySqlDir + 'mysqldump.exe --user=' + P.User
    + ' --password=' + P.Password + ' --databases ' + P.Database, 'c:\', 2000);
  Result := not s.StartsWith('mysqldump.exe: Got error:');
end;

{ TSuelBackupApp }

function TSuelBackupApp.CheckConfiguracao(): Boolean;
var
  AppConfig: TAppConfig;
  JsonObject: TJSONValue;
begin
  AppConfig := TAppConfig.Create;
  if TFile.Exists('config.json') then
  begin
    JsonObject := TJSONObject.ParseJSONValue(TFile.ReadAllText('config.json'))
  end
  else
  begin
    AppConfig := TAppConfig.Create;
    if AppConfig.ReecriarArquivo then
    begin
      Result := CheckConfiguracao();
    end;
  end;
end;

constructor TSuelBackupApp.Create();
begin
  inherited;

end;

class function TSuelBackupApp.GetDosOutput(CommandLine, Work: string;
  timeout: Cardinal): string;
var
  SA: TSecurityAttributes;
  SI: TStartupInfo;
  PI: TProcessInformation;
  StdOutPipeRead, StdOutPipeWrite: THandle;
  WasOK: Boolean;
  Buffer: array [0 .. 255] of AnsiChar;
  BytesRead: Cardinal;
  WorkDir: string;
  Handle: Boolean;
  OnTimeout: Boolean;
begin
  Result := '';
  with SA do
  begin
    nLength := SizeOf(SA);
    bInheritHandle := True;
    lpSecurityDescriptor := nil;
  end;
  CreatePipe(StdOutPipeRead, StdOutPipeWrite, @SA, 0);
  try
    with SI do
    begin
      FillChar(SI, SizeOf(SI), 0);
      cb := SizeOf(SI);
      dwFlags := STARTF_USESHOWWINDOW or STARTF_USESTDHANDLES;
      wShowWindow := SW_HIDE;
      hStdInput := GetStdHandle(STD_INPUT_HANDLE); // don't redirect stdin
      hStdOutput := StdOutPipeWrite;
      hStdError := StdOutPipeWrite;
    end;
    WorkDir := Work;
    Handle := CreateProcess(nil, PChar('cmd.exe /C ' + CommandLine), nil, nil,
      True, 0, nil, PChar(WorkDir), SI, PI);
    CloseHandle(StdOutPipeWrite);
    if Handle then
      try
        repeat
          WasOK := ReadFile(StdOutPipeRead, Buffer, 255, BytesRead, nil);
          if BytesRead > 0 then
          begin
            Buffer[BytesRead] := #0;
            Result := Result + Buffer;
          end;
        until not WasOK or (BytesRead = 0);
        WaitForSingleObject(PI.hProcess, timeout);
      finally
        CloseHandle(PI.hThread);
        CloseHandle(PI.hProcess);
      end;
  finally
    CloseHandle(StdOutPipeRead);
  end;
end;

procedure TSuelBackupApp.InicializarBackup;
begin

end;

procedure TSuelBackupApp.SendToOutPut(const _message: string);
begin

end;

{ TJSON }

function TJSON.B: TJSONObjectBuilder;
begin
  Result := FBuilder;
end;

procedure TJSON.clear;
begin
  self.FStringBuilder.Clear;
  self.FBuilder := self.FBuilder.Clear;
end;

constructor TJSON.Create;
begin
  FStringBuilder := TStringBuilder.Create;
  FStringWriter := TStringWriter.Create(FStringBuilder);
  FWriter := TJsonTextWriter.Create(FStringWriter);
  FBuilder := TJSONObjectBuilder.Create(FWriter);
end;

destructor TJSON.Destroy;
begin
  FBuilder.Free;
  FWriter.Free;
  FStringWriter.Free;
  FStringBuilder.Free;
end;

function TJSON.ToString: string;
begin
  Result := FStringBuilder.ToString;
end;

begin
  var
  App := TSuelBackupApp.Create;
  try
    if App.CheckConfiguracao() then
    begin
      App.InicializarBackup()
    end
  finally
    App.Free;
  end;

end.
